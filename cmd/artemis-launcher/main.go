/*
Copyright (c) 2018 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This program is intended to create and start ActiveMQ Artemis instances inside a Kubernetes or
// OpenShift container. It will use the 'artemis create' command to create the instance if the
// instance directory is empty.
//
// Before starting the instance it will optionally replace the default configuration files with
// alternative ones specified with the '--config' option. For example, that can be used to replace
// the default configuration files with other files included in a Kubernetes configuration map that
// is mounted in the container.
//
// It will also optionally take certificate and private keys files in PEM format and generate the
// PKCS #12 files that are supported by ActiveMQ Artemis.
//
// A typical usuage can be like this:
//
//	$ artemis-launcher \
//	--home=/usr/share/artemis \
//	--config=/etc/artemis \
//	--instance=/var/lib/artemis \
//	--console-cert=/etc/pki/tls/artemis/tls.crt \
//	--console-key=/etc/pki/tls/artemis/tls.key \
//	--console-keystore=/var/lib/artemis/etc/console.p12 \
//	--acceptors-cert=/etc/pki/tls/artemis/tls.crt \
//	--acceptors-key=/etc/pki/tls/artemis/tls.key \
//	--acceptors-keystore=/var/lib/artemis/etc/acceptors.p12
//
// See below, or use the '--help' option for a complete list of options.
package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"syscall"

	"github.com/spf13/pflag"
)

// Values of the command line options:
var args struct {
	home               string
	instance           string
	configs            []string
	consoleCertFile    string
	consoleKeyFile     string
	consoleKeyPass     string
	consoleStoreFile   string
	consoleStorePass   string
	acceptorsCertFile  string
	acceptorsKeyFile   string
	acceptorsKeyPass   string
	acceptorsStoreFile string
	acceptorsStorePass string
}

func main() {
	// We will need this:
	var err error

	// Register the global options:
	pflag.StringVar(
		&args.home,
		"home",
		"/usr/share/artemis",
		"The directory where ActiveMQ Artemis is installed.",
	)
	pflag.StringVar(
		&args.instance,
		"instance",
		"/var/lib/artemis",
		"The directory where the ActiveMQ Artemis instance exists, or where it will be "+
			"created, if it is empty.",
	)
	pflag.StringSliceVar(
		&args.configs,
		"config",
		[]string{},
		"The directory containing the configuration files that will be used to replace the "+
			"default ones generated by the 'artemis create' command. If given multiple "+
			"times they will be processed in the same order that they appear in the "+
			"command line.",
	)
	pflag.StringVar(
		&args.consoleCertFile,
		"console-cert",
		"",
		"The name of the PEM file containing the TLS certificate for the console. "+
			"Required when using the '--console-keystore' option.",
	)
	pflag.StringVar(
		&args.consoleKeyFile,
		"console-key",
		"",
		"The name of the PEM file containing the TLS private key for the console. "+
			"Required when using the '--console-keystore' option.",
	)
	pflag.StringVar(
		&args.consoleKeyPass,
		"console-key-password",
		"",
		"The password that was used to encrypt the TLS private key for the console.",
	)
	pflag.StringVar(
		&args.consoleStoreFile,
		"console-keystore",
		"",
		"The name of the PKCS #12 file that will contain the TLS certificate and private "+
			"key for the console. If this option is used, then the '--console-key' and "+
			"'--console-cert' are mandatory. The contents of those files will be "+
			"imported into a new PKCS #12 file that will be saved in the location "+
			"indicated by this option.",
	)
	pflag.StringVar(
		&args.consoleStorePass,
		"console-keystore-password",
		"",
		"The password that will be used to encrypt the PKCS #12 file for the console.",
	)
	pflag.StringVar(
		&args.acceptorsCertFile,
		"acceptors-cert",
		"",
		"The name of the PEM file containing the TLS certificate for the all the "+
			"acceptors. Required when using the '--acceptors-keystore' option.",
	)
	pflag.StringVar(
		&args.acceptorsKeyFile,
		"acceptors-key",
		"",
		"The name of the PEM file containing the TLS private key for the all the "+
			"acceptors. Required when using the '--acceptors-keystore' option.",
	)
	pflag.StringVar(
		&args.acceptorsKeyPass,
		"acceptors-key-password",
		"",
		"The password that was used to encrypt the TLS private key for the acceptors.",
	)
	pflag.StringVar(
		&args.acceptorsStoreFile,
		"acceptors-keystore",
		"",
		"The name of the PKCS #12 file that will contain the TLS certificate and private "+
			"key for all the acceptors. If this option is used, then the "+
			"'--console-key' and --console-cert' are mandatory. The contents of "+
			"those files will be imported into a new PKCS #12 file that will be "+
			"saved in the location indicated by this option.",
	)
	pflag.StringVar(
		&args.acceptorsStorePass,
		"acceptors-keystore-password",
		"",
		"The password that will be used to encrypt the PKCS #12 file for the acceptors.",
	)

	// Parse the command line:
	pflag.Parse()

	// Check the command line:
	ok := true
	if args.consoleStoreFile != "" {
		if args.consoleCertFile == "" {
			fmt.Printf(
				"The option '--console-cert' is mandatory when the option " +
					"'--console-keystore' is used.\n",
			)
			ok = false
		}
		if args.consoleKeyFile == "" {
			fmt.Printf(
				"The option '--console-key' is mandatory when the option " +
					"'--console-keystore' is used.\n",
			)
			ok = false
		}
	}
	if args.acceptorsStoreFile != "" {
		if args.acceptorsCertFile == "" {
			fmt.Printf(
				"The option '--acceptors-cert' is mandatory when the option " +
					"'--acceptors-keystore' is used.\n",
			)
			ok = false
		}
		if args.acceptorsKeyFile == "" {
			fmt.Printf(
				"The option '--acceptors-key' is mandatory when the option " +
					"'--acceptors-keystore' is used.\n",
			)
			ok = false
		}
	}
	if !ok {
		os.Exit(1)
	}

	// Check that the instance directory exists:
	_, err = os.Stat(args.instance)
	if err != nil {
		fmt.Printf(
			"The instance directory '%s' doesn't exist or can't be accessed: %s\n",
			args.instance,
			err.Error(),
		)
		os.Exit(1)
	}

	// To avoid potential overwrites of existing files we will try to initialize the instance
	// only if the directory is empty:
	infos, err := ioutil.ReadDir(args.instance)
	if err != nil {
		fmt.Printf(
			"Can't check if the instance directory '%s' is empty: %s\n",
			args.instance,
			err.Error(),
		)
		os.Exit(1)
	}
	if len(infos) == 0 {
		fmt.Printf(
			"The instance directory '%s' is empty, will try to initialize it\n",
			args.instance,
		)
		err = initInstance()
		if err != nil {
			fmt.Printf(
				"Can't initialize the instance in directory '%s': %s\n",
				args.instance,
				err.Error(),
			)
			os.Exit(1)
		}
	} else {
		fmt.Printf(
			"The instance directory '%s' isn't empty, will try to run it\n",
			args.instance,
		)
	}

	// Run the instance:
	err = runInstance()
	if err != nil {
		fmt.Printf(
			"Can't run the instance in directory '%s': %s\n",
			args.instance,
			err.Error(),
		)
		os.Exit(1)
	}

	// Bye:
	os.Exit(0)
}

func initInstance() error {
	var err error

	// Run the 'artemis create' command to initialize the instance. This will create a default
	// configuration that will then be adjusted, replacing some or all the configuration files
	// with the ones provided by the user of the image with the '--config' option.
	path := filepath.Join(args.home, "bin", "artemis")
	cmd := exec.Command(
		path,
		"create",
		"--home", args.home,
		"--name", "broker",
		"--host", "0.0.0.0",
		"--http-host", "0.0.0.0",
		"--allow-anonymous", "false",
		"--role", "admins",
		"--user", "admin",
		"--password", "admin",
		"--silent",
		args.instance,
	)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stdout
	err = cmd.Run()
	if err != nil {
		return fmt.Errorf(
			"execution of command '%s' failed: %s",
			path,
			err.Error(),
		)
	}

	return nil
}

func runInstance() error {
	var err error

	// Replace the configuration files genereated by the 'artemis create' command with the ones
	// provided by the user with the '--config' option.
	if len(args.configs) > 0 {
		for _, config := range args.configs {
			infos, err := ioutil.ReadDir(config)
			if err != nil {
				return fmt.Errorf(
					"can't list files in configuration directory '%s': %s",
					config,
					err.Error(),
				)
			}
			for _, info := range infos {
				if !info.IsDir() && !strings.HasPrefix(info.Name(), ".") {
					name := info.Name()
					src := filepath.Join(config, name)
					dst := filepath.Join(args.instance, "etc", name)
					err = copyFile(src, dst)
					if err != nil {
						return fmt.Errorf(
							"can't copy file '%s' to '%s': %s",
							src,
							dst,
							err.Error(),
						)
					}
				}
			}
		}
	}

	// Create the PKCS #12 files for the console and for the acceptors if needed:
	if args.consoleStoreFile != "" {
		err = createStoreFile(
			args.consoleCertFile,
			args.consoleKeyFile,
			args.consoleKeyPass,
			args.consoleStoreFile,
			args.consoleStorePass,
		)
		if err != nil {
			return err
		}
	}
	if args.acceptorsStoreFile != "" {
		err = createStoreFile(
			args.acceptorsCertFile,
			args.acceptorsKeyFile,
			args.acceptorsKeyPass,
			args.acceptorsStoreFile,
			args.acceptorsStorePass,
		)
		if err != nil {
			return err
		}
	}

	// Replace this process with the 'artemis run' command:
	path := filepath.Join(args.instance, "bin", "artemis")
	argv := []string{path, "run"}
	err = syscall.Exec(path, argv, nil)
	if err != nil {
		return fmt.Errorf(
			"execution of script '%s' failed: %s",
			argv,
			err.Error(),
		)
	}

	return nil
}

func createStoreFile(certFile, keyFile, keyPass, storeFile, storePass string) error {
	fmt.Printf(
		"Converting certificate '%s' and key '%s' to PKCS #12 '%s'\n",
		certFile,
		keyFile,
		storeFile,
	)
	cmd := exec.Command(
		"openssl",
		"pkcs12",
		"-export",
		"-in", certFile,
		"-inkey", keyFile,
		"-passin", "pass:"+keyPass,
		"-passout", "pass:"+storePass,
		"-out", storeFile,
	)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stdout
	err := cmd.Run()
	if err != nil {
		return fmt.Errorf(
			"can't convert certificate '%s' and key '%s' to PKCS #12 '%s' failed: %s",
			certFile,
			keyFile,
			err.Error(),
		)
	}
	return nil
}

func copyFile(src, dst string) error {
	fmt.Printf("Copying file '%s' to '%s'\n", src, dst)
	in, err := os.Open(src)
	if err != nil {
		return err
	}
	defer in.Close()
	out, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer out.Close()
	_, err = io.Copy(out, in)
	return err
}
